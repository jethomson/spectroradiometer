%
% This script demonstrates using so.Hr, the spectrometer's calibrated system
% function, and the output of a TSL230 irradiance sensor to create and check
% the radiometrically calibrated spectrum. Unlike so.Hu, so.Hr is the system
% function calibrated using data from the TSL230. The result of dividing the
% cyan LED's spectrum by so.Hr should result in a corrected and calibrated
% cyan LED spectrum. Since direct measurements of the LED by the TSL230 weren't
% used to calibrate, its calibration is referred to as an indirect calibration.
%
% This indirect calibration of the LED is compared to the direct calibration
% generated by using a measurement from the TSL230 and TSL230_fO_to_irradiance().
% The measurement conditions were favorable such that both the indirect and
% direct calibrations agree with each other. However, this might not always be
% the case.

% NB: It's best to always take TSL230 measurements of both the incandescent
% radiometric calibration lamp and the light source of interest. The first
% measurement is used to scale the model of the incandescent lamp's spectrum
% so that the system function will be scaled properly. The second measurement
% is used to scale the corrected spectrum of the light source of interest so
% that it agrees with what the TSL230 saw.
%
% After taking the spectrograph while the LED was pointed at the slit, I re-aimed
% the LED directly at the irradiance sensor. This was necessary because the LED
% is very directional. If your light source's radiation pattern is the same at
% the slit and TSL230 then you can take the irradiance measurement the same time
% you snap a spectrograph (i.e. you don't have to re-aim the light source).
%
% call spectrometer_setup and system_function_calibrated before running this script.
%

s = filesep;
so = access_spectrometer_object();

% the range of wavelengths where the spectrogram isn't mostly noise
l0 = 435; % [nm]
lf = 600; % [nm]

smooth_width = 11;
Ftri = triang(smooth_width);
Ftri = Ftri./sum(Ftri);

sd = [so.dir_light s 'spectrographs' s 'Cyan_LED_3'];
load([sd s so.ftype '_Cyan_LED_3_e0.mat' ]);

sensor_type = metadata.sensor_type;
fO = str2double(metadata.TSL230_fO); % [kHz]
sensitivity = str2double(metadata.TSL230_sensitivity);
distance = str2double(metadata.distance); % [m]

[ign, n0] = min(abs(so.lambda-l0));
[ign, nf] = min(abs(so.lambda-lf));

Z = image2spectrum(spctgrph);
Z = filtfilt(Ftri, 1, Z); % distorted spectrum, [count]
Ee = Z./so.Hr; % spectral irradiance, [W/m^2/nm]
Ee_green = Ee(n0:nf,2); % the green channel only

E1 = trapz(Ee_green).*(so.dlambda);

disp(['irradiance (E1) : ' num2str(E1) ' W/m^2 at distance '...
      num2str(distance) ' m.'])

% Ee_green is the indirectly calibrated spectral irradiance of the cyan LED, [W/m^2/nm]
% Ee2 is the directly calibrated spectral irradiance of the cyan LED, [W/m^2/nm]
Ee2 = TSL230_fO_to_irradiance(so.lambda(n0:nf), Ee_green, fO, sensitivity, sensor_type, 'power');

% spectrum corrected using the irradiance meter's measurement
E2 = trapz(Ee2).*(so.dlambda);
disp(['irradiance (E2) : ' num2str(E2) ' W/m^2 at distance '...
      num2str(distance) ' m.'])

pct_err = 100*(E1-E2)/E2;
disp(['total irradiant flux percent error 100*(E1-E2)/E2: ' num2str(pct_err) '%'])

figure, hold on
plot(so.lambda(n0:nf), Ee_green, 'g')
plot(so.lambda(n0:nf), Ee2, 'r')
axis([l0 lf 0 1.1*max(Ee2)])
ylabel('spectral irradiance [W/m^2/nm]')
xlabel('wavelength [nm]')
title('cyan LED spectrum calibration comparison')
legend('indirectly calibrated', 'directly calibrated')

break % uncomment to see a comparison to a Gaussian
% model the LED's spectrum with a Gaussian.
h = 6.62606896*10^-34; % Planck constant, [J*s]
c = 299792458; % speed of light, [m/s]
Wp = h*c./(so.lambda*10^-9); % [J/photon]

mu = 505;
FWHM = 40;
Xcyan = exp(-2.7726*((so.lambda-mu)/FWHM).^2);
%Xcyan = Wp.*exp(-2.7726*((so.lambda-mu)/FWHM).^2);

Ee3 = TSL230_fO_to_irradiance(so.lambda, Xcyan, fO, sensitivity, sensor_type, 'power');

E3 = trapz(Ee3(n0:nf)).*(so.dlambda);
disp(['irradiance (E3) : ' num2str(E3) ' W/m^2 at distance '...
      num2str(distance) ' m.'])

plot(so.lambda, Ee3, 'k')

pct_err = 100*(E3-E2)/E2;
disp(['total irradiant flux percent error 100*(E3-E2)/E2: ' num2str(pct_err) '%'])

legend('indirectly calibrated', 'directly calibrated', 'Gaussian model')
